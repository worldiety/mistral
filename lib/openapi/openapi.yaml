openapi: 3.0.1
info:
  title: worldiety mistral
  version: 1.20.0
  description: |
    *mistral* is a very specialized database powered by *worldiety* which supports the storage and retrieval of time based sensor metrics for devices. It scales quite well for billions of values on a single node.

  license:
    name: worldiety Enterprise Edition (EE) Lizenz (die "EE Lizenz")
    url: https://worldiety.github.io/mistral/LICENSE


  x-logo:
    url: 'https://worldiety.github.io/mistral/wdy-logo.svg'
    altText: 'worldiety logo'
    href: https://www.worldiety.de/produkte/mistral


servers:
  - url: "https://mistral.worldiety.net"



tags:
  - name: status
    description: |
      This resource provides basic health information about the service.
      It is conventionally provided to support a hosting within complex infrastructures 
      like kubernetes. A successful response does not mean that everything is actually
      fine. It just executes some basic checks and inspections to prove that in general
      the service should be able to process requests.

  - name: buckets
    description: |
      Resources of _buckets_ provide access to both, meta data and actual time series data.
      A bucket represents usually a device like a wind generator but may also be used
      for other time-based data required e.g. for accounting.
      
      Advanced querying and aggregation is only possible by using the computational kernel API.
  - name: bucketgroups
    description: |
      Resources of _bucketgroups_ represent groups of buckets (or devices), often known as portfolios.
      This resource is purely virtual and can be used to simplify the development and 
      usage of computational kernels. 
      
      For example, it may make sense to create a group
      representing a clients portfolio of wind generators he owns. Then, a compute kernel
      may just take the group identifier to load all contained bucket identifiers itself.

  - name: kernels
    description: |
      Resources of _kernels_ represent the compute kernels written in the MiEl language - 
      a subset respective dialect of the Go programming language. 
      You should avoid the creation or modification of kernels from end-users, to
      protect your service against DoS-like attacks. Even though the execution is sandboxed
      and that there is no standard library available, a kernel can still consume an unreasonable
      amount of CPU or memory resources.
      
      Mistral distributes and schedules these kernels as execution is requested.
      A kernel usually assembles a pipeline of pre-compiled fixed-function aggregation
      algorithms and transforms the result into an arbitrary (json) structure.
      This avoid to transfer and serialize large sets of data through the network, which
      otherwise would degrade system performance multiple orders of magnitude.
      Thus, always keep in mind to bring the computation to the data (your MiEL compute kernel)
      instead of just serializing the data over the wire into your middleware.
      
      Mistral also provides a bunch of build-in and ready-to-use kernels, which cannot be modified and
      may be optimized and updated in future releases. These kernels are especially useful
      for basic inspection and data analysis tasks.
      
      Example for a MiEl compute kernel:
      
      ```go
      package main

      import (
        "context"
        miel "github.com/worldiety/mistral/lib/go/dsl/v1"
      )

      type Request struct {
        Buckets []miel.UUID `json:"buckets"`
        Metric  miel.UUID   `json:"metric"`
        Range   miel.Range  `json:"range"`
      }

      type Response struct {
        BucketNames []string    `json:"names"`
        MetricName  string      `json:"metric"`
        Data        miel.FGroup `json:"data"`
      }

      func Declare() (interface{}, interface{}) {
        return Request{
            Buckets: []miel.UUID{miel.NewUUID()},
            Metric:  miel.NewUUID(),
            Range:   "[2038-01-19 03:14:07,2038-01-19 03:14:07]@Europe/Berlin",
          }, Response{
            BucketNames: []string{"wind generator"},
            MetricName:  "Windspeed in km/h",
            Data:        miel.FGroup{miel.FPoints{miel.FPoint{X: 1648826693, Y: 3.14}}},
          }
      }

      func Eval(ctx context.Context) {
        var request Request
        miel.Request(ctx, &request)

        scale := miel.Query(ctx).ScaleOf(request.Metric)
        width := miel.ViewportWidth(ctx)

        miel.Query(ctx).
          FindInRange(request.Buckets, request.Metric, request.Range.MustInterval()).
          ForEachF(func(pts miel.Points) miel.FPoints {
            return pts.Downscale(width).Unscale(scale)
          })

        miel.Response(ctx, Response{})
      }

      func main() {
        miel.Configure().
          Parameter(Declare).
          Start(Eval)
      }
      ```

  - name: timeseries
    description: |
      Resources of _timeseries_ allows access to ranges of stored time series data within a specific
      bucket and metric. 
      All time series data within a bucket and metric is treated uniquely per time stamp, which should
      be represented as a Unix timestamp in seconds since Epoch, which is also expected by
      all [MiEl kernel functions](#tag/kernels).

  - name: metrics
    description: |
      Resources of _metrics_ is a loosely coupled conventional meta data aggregation for details about metrics.
      Time series data is shared per bucket and uniquely addressed using a metric id.
      To commonly manage information about a specific metric id, these resource can be used.
      

paths:

  #########################################################
  # Status endpoint
  #########################################################

  /healthz:
    $ref: './v1/status/paths.yaml#/healthz'

  /api/v1/metrics:
    $ref: './v1/metrics/paths.yaml#/metrics'

  /api/v1/buckets:
    $ref: './v1/buckets/paths.yaml#/buckets'

  /api/v1/buckets/{id}:
    $ref: './v1/buckets/paths.yaml#/buckets-{id}'

  /api/v1/buckets/{bucket-id}/timeseries/{metric-id}:
    $ref: './v1/buckets/timeseries.yaml#/timeseries'

  /api/v1/bucketgroups:
    $ref: './v1/bucketgroups/paths.yaml#/bucketgroups'

  /api/v1/bucketgroups/{id}:
    $ref: './v1/bucketgroups/paths.yaml#/bucketgroups-{id}'

  /api/v1/kernels:
    $ref: './v1/kernels/paths.yaml#/kernels'


  /api/v1/kernels/{id}:
    $ref: './v1/kernels/paths.yaml#/kernels-{id}'

  /api/v1/eval/kernel:
    $ref: './v1/kernels/eval.yaml#/eval'

  /api/v1/kernels/{id}/run:
    $ref: './v1/kernels/run.yaml#/run'

  /api/v1/kernels/{id}/parameter:
    $ref: './v1/kernels/params.yaml#/params'

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      description: |
        Securitywise, mistral does not provide its own authentication or authorization
        infrastructure. The intended modus operandi locates mistral into a private
        network, with a custom gateway API or middleware in front of it. 
        There is no ownership of buckets, time series data or users in general, which
        also means, that this kind of authorization must be guaranteed by the according 
        upstream service. Therefore, there is only a single basic level of security, based
        on a secret bearer token, which must be exchanged through an external secure channel.
        Usually, you want to exchange and deploy these secrets at least through
        dynamic environment variables within your deployment infrastructure.